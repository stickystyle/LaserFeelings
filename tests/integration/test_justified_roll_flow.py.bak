# ABOUTME: Integration tests for justified roll flow with character suggestions and DM adjudication.
# ABOUTME: Tests end-to-end dice roll scenarios including DM acceptance, override, and character helping.

import json
from datetime import datetime, timezone
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from redis import Redis
from rq import Queue

from src.interface.dm_cli import DMCommandLineInterface, DMCommandParser
from src.models.dice_models import RollOutcome
from src.models.game_state import GamePhase
from src.orchestration.state_machine import TurnOrchestrator
from src.utils.dice import roll_lasers_feelings


@pytest.fixture
def mock_redis_for_integration():
    """Mock Redis client for integration tests with stateful behavior"""
    redis = MagicMock(spec=Redis)

    # Track state in a dict
    state_store = {}

    def mock_hset(key, field, value):
        if key not in state_store:
            state_store[key] = {}
        state_store[key][field] = value
        return 1

    def mock_hget(key, field):
        return state_store.get(key, {}).get(field)

    def mock_hgetall(key):
        return state_store.get(key, {})

    def mock_exists(key):
        return 1 if key in state_store else 0

    # Configure mock methods
    redis.hset = MagicMock(side_effect=mock_hset)
    redis.hget = MagicMock(side_effect=mock_hget)
    redis.hgetall = MagicMock(side_effect=mock_hgetall)
    redis.exists = MagicMock(side_effect=mock_exists)
    redis.delete = MagicMock(return_value=1)
    redis.rpush = MagicMock(return_value=1)
    redis.lrange = MagicMock(return_value=[])
    redis.lpop = MagicMock(return_value=None)
    redis.set = MagicMock(return_value=True)
    redis.setex = MagicMock(return_value=True)
    redis.expire = MagicMock(return_value=True)
    redis.keys = MagicMock(return_value=[])
    redis.ping = MagicMock(return_value=True)

    return redis


@pytest.fixture
def mock_rq_queue():
    """Mock RQ Queue for worker job dispatch"""
    queue = MagicMock(spec=Queue)

    def mock_enqueue(func, *args, **kwargs):
        """Mock job enqueue - returns a completed job immediately"""
        job = MagicMock()
        job.id = f"job_{func.__name__}"
        job.is_failed = False
        job.refresh = MagicMock()

        # Call the function synchronously to simulate completed job
        try:
            result = func(*args, **kwargs)
            job.result = result
        except Exception as e:
            job.result = None
            job.is_failed = True
            job.exc_info = str(e)

        return job

    queue.enqueue = MagicMock(side_effect=mock_enqueue)
    return queue


@pytest.fixture
def zara_character_config(tmp_path):
    """Create Zara-7 character config file for testing"""
    config_dir = tmp_path / "config" / "personalities"
    config_dir.mkdir(parents=True, exist_ok=True)

    character_config = {
        "character_id": "char_001_001",
        "name": "Zara-7",
        "style": "Android",
        "role": "Engineer",
        "number": 2,  # Good at Lasers (logic/tech)
        "character_goal": "Maintain ship systems and solve technical problems",
        "equipment": ["Omnitool", "Diagnostic Scanner", "Repair Kit"]
    }

    config_file = config_dir / "char_001_001_character.json"
    with open(config_file, "w") as f:
        json.dump(character_config, f)

    return config_file


@pytest.fixture
def kai_character_config(tmp_path):
    """Create Kai Nova character config file for testing"""
    config_dir = tmp_path / "config" / "personalities"
    config_dir.mkdir(parents=True, exist_ok=True)

    character_config = {
        "character_id": "char_002_001",
        "name": "Kai Nova",
        "style": "Intrepid",
        "role": "Explorer",
        "number": 3,  # Balanced
        "character_goal": "Discover ancient ruins and map the unknown",
        "equipment": ["Scanner", "Grappling hook", "Field journal"]
    }

    config_file = config_dir / "char_002_001_character.json"
    with open(config_file, "w") as f:
        json.dump(character_config, f)

    return config_file


class TestFullTurnWithCharacterSuggestedRoll:
    """Test Scenario 1: DM accepts character's suggested roll"""

    @patch("src.orchestration.state_machine.Queue")
    @patch("src.config.settings.Settings")
    def test_character_suggests_roll_dm_accepts(
        self,
        mock_settings_class,
        mock_queue_class,
        mock_redis_for_integration,
        mock_rq_queue,
        zara_character_config,
        tmp_path,
        monkeypatch
    ):
        """
        Full turn: Character suggests 3d6 roll (prepared + expert), DM accepts with /roll.

        Verifies:
        - Character performs action with dice suggestion
        - DM sees justifications displayed
        - DM types /roll (no args) to accept suggestion
        - System executes Lasers & Feelings roll with 3d6
        - Roll result is stored in state
        - DM provides outcome narration
        - Character reacts to outcome
        - All data stored correctly
        """
        # Change working directory to tmp_path so character config is found
        monkeypatch.chdir(tmp_path)

        # Mock settings
        mock_settings = MagicMock()
        mock_settings.openai_api_key = "test-key"
        mock_settings.openai_model = "gpt-4o"
        mock_settings.redis_url = "redis://localhost:6379"
        mock_settings_class.return_value = mock_settings

        # Configure Queue mock to return our mock queue
        mock_queue_class.return_value = mock_rq_queue

        # Mock OpenAI responses
        mock_openai = MagicMock()

        def mock_create(*args, **kwargs):
            """Context-aware OpenAI responses"""
            messages = kwargs.get("messages", [])
            prompt_content = " ".join([m.get("content", "") for m in messages]).lower()

            # Strategic intent
            if "strategic_goal" in prompt_content:
                content = json.dumps({
                    "agent_id": "agent_001",
                    "strategic_goal": "Repair the ship's damaged power relay",
                    "reasoning": "Power systems are critical for ship operation",
                    "risk_assessment": "Low risk - I'm an expert engineer",
                    "fallback_plan": "Request assistance from another crew member"
                })
            # Directive
            elif "instruction" in prompt_content and "to_character" in prompt_content:
                content = json.dumps({
                    "from_player": "agent_001",
                    "to_character": "char_001_001",
                    "instruction": "Use your technical expertise to repair the power relay",
                    "emotional_tone": "confident"
                })
            # Character action with dice suggestion
            elif "narrative_text" in prompt_content and "scene" in prompt_content:
                content = json.dumps({
                    "character_id": "char_001_001",
                    "narrative_text": "I carefully open the power relay panel and begin diagnostics. 'Running full system analysis,' I state calmly.",
                    "task_type": "lasers",
                    "is_prepared": True,
                    "prepared_justification": "I brought my diagnostic scanner and repair kit specifically for this task",
                    "is_expert": True,
                    "expert_justification": "As the ship's engineer, I have extensive training in power systems",
                    "is_helping": False
                })
            # Character reaction
            elif "narrative_text" in prompt_content and "outcome" in prompt_content:
                content = json.dumps({
                    "character_id": "char_001_001",
                    "narrative_text": "The relay hums back to life. 'Power restored to optimal levels,' I report with satisfaction."
                })
            else:
                content = "Acknowledged"

            return MagicMock(
                choices=[MagicMock(message=MagicMock(content=content))],
                model="gpt-4o"
            )

        mock_openai.chat.completions.create = AsyncMock(side_effect=mock_create)

        # Patch OpenAI client - patch the openai module directly
        with patch("openai.AsyncOpenAI", return_value=mock_openai):
            # Initialize orchestrator
            orchestrator = TurnOrchestrator(mock_redis_for_integration)

            # Execute turn cycle (will interrupt at adjudication)
            turn_result = orchestrator.execute_turn_cycle(
                dm_input="The ship's power relay sparks and fails. Warning lights flash across the bridge.",
                active_agents=["agent_001"],
                turn_number=1,
                session_number=1
            )

            # Verify turn interrupted at DM adjudication
            assert turn_result["awaiting_dm_input"] is True
            assert turn_result["awaiting_phase"] == "dm_adjudication"

            # Verify character action includes dice suggestion
            character_actions = turn_result["character_actions"]
            assert "char_001_001" in character_actions
            action_dict = character_actions["char_001_001"]

            assert action_dict["task_type"] == "lasers"
            assert action_dict["is_prepared"] is True
            assert action_dict["is_expert"] is True
            assert "diagnostic scanner" in action_dict["prepared_justification"].lower()
            assert "engineer" in action_dict["expert_justification"].lower()

            # Simulate DM accepting character's suggestion with /roll (no args)
            # This should trigger Lasers & Feelings roll with 3d6 (base + prepared + expert)

            # Mock the roll_lasers_feelings result for deterministic testing
            mock_roll_result = MagicMock()
            mock_roll_result.character_number = 2
            mock_roll_result.task_type = "lasers"
            mock_roll_result.is_prepared = True
            mock_roll_result.is_expert = True
            mock_roll_result.is_helping = False
            mock_roll_result.individual_rolls = [1, 1, 2]  # All successes for number=2 Lasers
            mock_roll_result.die_successes = [True, True, False]  # 2 successes
            mock_roll_result.laser_feelings_indices = [2]  # Third die is exact match
            mock_roll_result.total_successes = 2
            mock_roll_result.outcome = RollOutcome.SUCCESS
            mock_roll_result.has_laser_feelings = True
            mock_roll_result.dice_count = 3
            mock_roll_result.timestamp = datetime.now(timezone.utc)
            mock_roll_result.gm_question = None
            mock_roll_result.model_dump = MagicMock(return_value={
                "character_number": 2,
                "task_type": "lasers",
                "is_prepared": True,
                "is_expert": True,
                "is_helping": False,
                "individual_rolls": [1, 1, 2],
                "die_successes": [True, True, False],
                "laser_feelings_indices": [2],
                "total_successes": 2,
                "outcome": "success",
                "has_laser_feelings": True,
                "dice_count": 3,
                "timestamp": mock_roll_result.timestamp.isoformat(),
                "gm_question": None
            })

            with patch("src.utils.dice.roll_lasers_feelings", return_value=mock_roll_result):
                # Resume turn with adjudication using character's suggestion
                adjudication_result = orchestrator.resume_turn_with_dm_input(
                    session_number=1,
                    dm_input_type="adjudication",
                    dm_input_data={
                        "needs_dice": True,
                        "lasers_feelings_result": mock_roll_result.model_dump()
                    }
                )

                # Verify turn interrupted again at DM outcome
                assert adjudication_result["awaiting_dm_input"] is True
                assert adjudication_result["awaiting_phase"] == "dm_outcome"

                # Provide DM outcome narration
                final_result = orchestrator.resume_turn_with_dm_input(
                    session_number=1,
                    dm_input_type="outcome",
                    dm_input_data={
                        "outcome_text": "The power relay repairs perfectly. Systems come back online with full power."
                    }
                )

                # Verify turn completed successfully
                assert final_result["success"] is True
                assert final_result["phase_completed"] == GamePhase.MEMORY_STORAGE.value

                # Verify dice roll results stored correctly
                assert "dice_roll_result" in final_result
                dice_data = final_result["dice_roll_result"]
                assert dice_data["character_number"] == 2
                assert dice_data["task_type"] == "lasers"
                assert dice_data["is_prepared"] is True
                assert dice_data["is_expert"] is True
                assert dice_data["total_successes"] == 2
                assert dice_data["outcome"] == "success"
                assert len(dice_data["individual_rolls"]) == 3

                # Verify character reactions present
                assert "character_reactions" in final_result
                assert "char_001_001" in final_result["character_reactions"]


class TestFullTurnWithDMOverride:
    """Test Scenario 2: DM overrides character's suggestion"""

    @patch("src.orchestration.state_machine.Queue")
    @patch("src.config.settings.Settings")
    def test_dm_overrides_character_suggestion(
        self,
        mock_settings_class,
        mock_queue_class,
        mock_redis_for_integration,
        mock_rq_queue,
        zara_character_config,
        tmp_path,
        monkeypatch
    ):
        """
        Full turn: Character suggests 3d6 (prepared + expert), DM overrides with 1d6.

        Verifies:
        - Character suggests 3d6 roll
        - DM types /roll 1d6 to override
        - System uses DM's specification (1d6), not character's suggestion
        - Roll executes with DM's formula
        - Turn completes with DM override data
        """
        # Change working directory to tmp_path
        monkeypatch.chdir(tmp_path)

        # Mock settings
        mock_settings = MagicMock()
        mock_settings.openai_api_key = "test-key"
        mock_settings.openai_model = "gpt-4o"
        mock_settings.redis_url = "redis://localhost:6379"
        mock_settings_class.return_value = mock_settings

        # Configure Queue mock
        mock_queue_class.return_value = mock_rq_queue

        # Mock OpenAI responses
        mock_openai = MagicMock()

        def mock_create(*args, **kwargs):
            messages = kwargs.get("messages", [])
            prompt_content = " ".join([m.get("content", "") for m in messages]).lower()

            if "strategic_goal" in prompt_content:
                content = json.dumps({
                    "agent_id": "agent_001",
                    "strategic_goal": "Override security lockdown",
                    "reasoning": "Need access to restricted area",
                    "risk_assessment": "Moderate risk",
                    "fallback_plan": "Find alternate route"
                })
            elif "instruction" in prompt_content:
                content = json.dumps({
                    "from_player": "agent_001",
                    "to_character": "char_001_001",
                    "instruction": "Hack the security terminal",
                    "emotional_tone": "focused"
                })
            elif "narrative_text" in prompt_content and "scene" in prompt_content:
                content = json.dumps({
                    "character_id": "char_001_001",
                    "narrative_text": "I interface with the security terminal, running encryption bypass protocols.",
                    "task_type": "lasers",
                    "is_prepared": True,
                    "prepared_justification": "I brought specialized hacking tools",
                    "is_expert": True,
                    "expert_justification": "I'm trained in security systems",
                    "is_helping": False
                })
            elif "narrative_text" in prompt_content and "outcome" in prompt_content:
                content = json.dumps({
                    "character_id": "char_001_001",
                    "narrative_text": "Access denied. The system locks me out."
                })
            else:
                content = "Acknowledged"

            return MagicMock(
                choices=[MagicMock(message=MagicMock(content=content))],
                model="gpt-4o"
            )

        mock_openai.chat.completions.create = AsyncMock(side_effect=mock_create)

        with patch("openai.AsyncOpenAI", return_value=mock_openai):
            orchestrator = TurnOrchestrator(mock_redis_for_integration)

                # Execute turn
                turn_result = orchestrator.execute_turn_cycle(
                    dm_input="A locked security terminal blocks your path.",
                    active_agents=["agent_001"],
                    turn_number=1,
                    session_number=1
                )

                assert turn_result["awaiting_dm_input"] is True
                assert turn_result["awaiting_phase"] == "dm_adjudication"

                # Verify character suggested 3d6
                action_dict = turn_result["character_actions"]["char_001_001"]
                assert action_dict["is_prepared"] is True
                assert action_dict["is_expert"] is True
                # Would be 3d6 (base + prepared + expert)

                # DM overrides with 1d6 using /roll 1d6 command
                # This bypasses character's suggestion entirely

                # Mock a simple 1d6 roll result (DM override)
                with patch("src.utils.dice.roll_dice") as mock_roll_dice:
                    mock_dice_result = MagicMock()
                    mock_dice_result.notation = "1d6"
                    mock_dice_result.individual_rolls = [4]
                    mock_dice_result.total = 4
                    mock_dice_result.modifier = 0
                    mock_roll_dice.return_value = mock_dice_result

                    # Resume with DM override
                    adjudication_result = orchestrator.resume_turn_with_dm_input(
                        session_number=1,
                        dm_input_type="adjudication",
                        dm_input_data={
                            "needs_dice": True,
                            "dice_override": 4  # DM rolled 1d6 = 4
                        }
                    )

                    assert adjudication_result["awaiting_dm_input"] is True
                    assert adjudication_result["awaiting_phase"] == "dm_outcome"

                    # Provide outcome
                    final_result = orchestrator.resume_turn_with_dm_input(
                        session_number=1,
                        dm_input_type="outcome",
                        dm_input_data={
                            "outcome_text": "The terminal rejects your hack attempt. Alarms begin to sound."
                        }
                    )

                    # Verify turn completed
                    assert final_result["success"] is True

                    # Verify DM override was used (dice_override field in state)
                    # The dice_result field should reflect DM's roll, not character's suggestion


class TestCharacterHelpingAnotherCharacter:
    """Test Scenario 3: Character helping another character"""

    @patch("src.orchestration.state_machine.Queue")
    @patch("src.config.settings.Settings")
    def test_character_helps_another_max_3d6(
        self,
        mock_settings_class,
        mock_queue_class,
        mock_redis_for_integration,
        mock_rq_queue,
        zara_character_config,
        kai_character_config,
        tmp_path,
        monkeypatch
    ):
        """
        Full turn: Character A performs action (2d6), Character B helps (+1d6), total capped at 3d6.

        Verifies:
        - Character A suggests 2d6 (prepared + expert)
        - Character B helps Character A (suggests +1d6)
        - DM sees both suggestions combined
        - DM types /roll
        - System calculates total correctly (3d6 max)
        - Roll executes with combined modifiers
        """
        # Change working directory
        monkeypatch.chdir(tmp_path)

        # Mock settings
        mock_settings = MagicMock()
        mock_settings.openai_api_key = "test-key"
        mock_settings.openai_model = "gpt-4o"
        mock_settings.redis_url = "redis://localhost:6379"
        mock_settings_class.return_value = mock_settings

        # Configure Queue mock
        mock_queue_class.return_value = mock_rq_queue

        # Mock OpenAI responses
        mock_openai = MagicMock()

        def mock_create(*args, **kwargs):
            messages = kwargs.get("messages", [])
            prompt_content = " ".join([m.get("content", "") for m in messages]).lower()

            # Agent 001 (Zara) strategic intent
            if "agent_001" in str(kwargs) and "strategic_goal" in prompt_content:
                content = json.dumps({
                    "agent_id": "agent_001",
                    "strategic_goal": "Lift the heavy debris blocking the door",
                    "reasoning": "We need to access the corridor beyond",
                    "risk_assessment": "Low risk with assistance",
                    "fallback_plan": "Find alternate route"
                })
            # Agent 002 (Kai) strategic intent
            elif "agent_002" in str(kwargs) and "strategic_goal" in prompt_content:
                content = json.dumps({
                    "agent_id": "agent_002",
                    "strategic_goal": "Assist Zara-7 in lifting the debris",
                    "reasoning": "Two people can lift more safely",
                    "risk_assessment": "Low risk working together",
                    "fallback_plan": "Search for tools"
                })
            # Directives
            elif "instruction" in prompt_content and "char_001_001" in prompt_content:
                content = json.dumps({
                    "from_player": "agent_001",
                    "to_character": "char_001_001",
                    "instruction": "Use your strength to lift the debris",
                    "emotional_tone": "determined"
                })
            elif "instruction" in prompt_content and "char_002_001" in prompt_content:
                content = json.dumps({
                    "from_player": "agent_002",
                    "to_character": "char_002_001",
                    "instruction": "Help Zara-7 lift the debris",
                    "emotional_tone": "supportive"
                })
            # Character A action (prepared + expert = 2d6 before help)
            elif "char_001_001" in prompt_content and "narrative_text" in prompt_content:
                content = json.dumps({
                    "character_id": "char_001_001",
                    "narrative_text": "I brace myself and grip the debris. 'On three,' I announce.",
                    "task_type": "lasers",
                    "is_prepared": True,
                    "prepared_justification": "I assessed the weight and positioned optimally",
                    "is_expert": True,
                    "expert_justification": "My android strength is ideal for this task",
                    "is_helping": False
                })
            # Character B action (helping Character A)
            elif "char_002_001" in prompt_content and "narrative_text" in prompt_content:
                content = json.dumps({
                    "character_id": "char_002_001",
                    "narrative_text": "I position myself beside Zara-7. 'Ready!' I confirm.",
                    "task_type": "lasers",
                    "is_prepared": False,
                    "is_expert": False,
                    "is_helping": True,
                    "helping_character_id": "char_001_001",
                    "help_justification": "I'm adding my strength to assist Zara-7's lift"
                })
            # Reactions
            elif "outcome" in prompt_content:
                content = json.dumps({
                    "character_id": "char_001_001",
                    "narrative_text": "Together we heave the debris aside. 'Clear!' I call out."
                })
            else:
                content = "Acknowledged"

            return MagicMock(
                choices=[MagicMock(message=MagicMock(content=content))],
                model="gpt-4o"
            )

        mock_openai.chat.completions.create = AsyncMock(side_effect=mock_create)

        with patch("openai.AsyncOpenAI", return_value=mock_openai):
            orchestrator = TurnOrchestrator(mock_redis_for_integration)

                # Execute turn with two agents
                turn_result = orchestrator.execute_turn_cycle(
                    dm_input="Heavy debris blocks the corridor. It will take strength to move it.",
                    active_agents=["agent_001", "agent_002"],
                    turn_number=1,
                    session_number=1
                )

                assert turn_result["awaiting_dm_input"] is True

                # Verify both characters' actions
                character_actions = turn_result["character_actions"]
                assert "char_001_001" in character_actions
                assert "char_002_001" in character_actions

                # Character A: prepared + expert = would be 3d6 before help
                char_a_action = character_actions["char_001_001"]
                assert char_a_action["is_prepared"] is True
                assert char_a_action["is_expert"] is True
                assert char_a_action["is_helping"] is False

                # Character B: helping Character A
                char_b_action = character_actions["char_002_001"]
                assert char_b_action["is_helping"] is True
                assert char_b_action["helping_character_id"] == "char_001_001"

                # Combined: 1 base + 1 prepared + 1 expert + 1 helping = 4d6
                # But max is 3d6, so should cap at 3

                # Mock roll result for 3d6 (capped)
                mock_roll_result = MagicMock()
                mock_roll_result.character_number = 2
                mock_roll_result.task_type = "lasers"
                mock_roll_result.is_prepared = True
                mock_roll_result.is_expert = True
                mock_roll_result.is_helping = True
                mock_roll_result.individual_rolls = [1, 1, 1]  # All successes
                mock_roll_result.die_successes = [True, True, True]
                mock_roll_result.laser_feelings_indices = []
                mock_roll_result.total_successes = 3
                mock_roll_result.outcome = RollOutcome.CRITICAL
                mock_roll_result.has_laser_feelings = False
                mock_roll_result.dice_count = 3  # Capped at 3
                mock_roll_result.timestamp = datetime.now(timezone.utc)
                mock_roll_result.model_dump = MagicMock(return_value={
                    "character_number": 2,
                    "task_type": "lasers",
                    "is_prepared": True,
                    "is_expert": True,
                    "is_helping": True,
                    "individual_rolls": [1, 1, 1],
                    "die_successes": [True, True, True],
                    "laser_feelings_indices": [],
                    "total_successes": 3,
                    "outcome": "critical",
                    "dice_count": 3,
                    "timestamp": mock_roll_result.timestamp.isoformat()
                })

                with patch("src.utils.dice.roll_lasers_feelings", return_value=mock_roll_result):
                    # DM accepts combined roll
                    adjudication_result = orchestrator.resume_turn_with_dm_input(
                        session_number=1,
                        dm_input_type="adjudication",
                        dm_input_data={
                            "needs_dice": True,
                            "lasers_feelings_result": mock_roll_result.model_dump()
                        }
                    )

                    assert adjudication_result["awaiting_dm_input"] is True

                    # Provide outcome
                    final_result = orchestrator.resume_turn_with_dm_input(
                        session_number=1,
                        dm_input_type="outcome",
                        dm_input_data={
                            "outcome_text": "Working together, you easily shift the massive debris. The corridor is clear."
                        }
                    )

                    # Verify turn completed
                    assert final_result["success"] is True

                    # Verify roll used all three modifiers (capped at 3d6)
                    dice_data = final_result["dice_roll_result"]
                    assert dice_data["is_prepared"] is True
                    assert dice_data["is_expert"] is True
                    assert dice_data["is_helping"] is True
                    assert len(dice_data["individual_rolls"]) == 3  # Max 3 dice
                    assert dice_data["total_successes"] == 3  # Critical success


class TestCLIIntegrationWithJustifiedRoll:
    """Test CLI integration with justified roll display and parsing"""

    def test_cli_displays_dice_suggestions(self, zara_character_config, tmp_path, monkeypatch):
        """
        Test that CLI correctly displays dice suggestions with justifications.

        Verifies:
        - CLI formatter shows task type
        - CLI formatter shows prepared flag + justification
        - CLI formatter shows expert flag + justification
        - CLI formatter shows suggested roll formula
        """
        monkeypatch.chdir(tmp_path)

        cli = DMCommandLineInterface()

        # Create action dict with dice suggestion
        action_dict = {
            "character_id": "char_001_001",
            "narrative_text": "I attempt to repair the reactor core.",
            "task_type": "lasers",
            "is_prepared": True,
            "prepared_justification": "I studied the reactor schematics before attempting this repair",
            "is_expert": True,
            "expert_justification": "As chief engineer, reactor maintenance is my specialty",
            "is_helping": False
        }

        # Format dice suggestion
        suggestion = cli.formatter.format_dice_suggestion(action_dict)

        # Verify output contains all key information
        assert suggestion is not None
        assert "Dice Roll Suggestion:" in suggestion
        assert "Lasers" in suggestion
        assert "logic/tech" in suggestion
        assert "Prepared:" in suggestion
        assert "studied the reactor schematics" in suggestion
        assert "Expert:" in suggestion
        assert "reactor maintenance is my specialty" in suggestion
        assert "3d6" in suggestion  # 1 base + prepared + expert

    def test_cli_parser_handles_roll_without_args(self):
        """
        Test that parser correctly handles /roll with no arguments (use character suggestion).

        Verifies:
        - /roll parses successfully
        - args dict is empty (no notation)
        - This indicates "use character's suggestion"
        """
        parser = DMCommandParser()

        # Parse /roll with no args
        parsed = parser.parse("/roll")

        assert parsed.command_type.value == "roll"
        assert parsed.args == {}  # Empty args = use character suggestion

    def test_cli_parser_handles_roll_with_override(self):
        """
        Test that parser correctly handles /roll with DM override notation.

        Verifies:
        - /roll 1d6 parses successfully
        - args dict contains notation
        - This indicates "DM override"
        """
        parser = DMCommandParser()

        # Parse /roll with override
        parsed = parser.parse("/roll 1d6")

        assert parsed.command_type.value == "roll"
        assert "notation" in parsed.args
        assert parsed.args["notation"] == "1d6"

    def test_cli_displays_helping_suggestion(self, zara_character_config, kai_character_config, tmp_path, monkeypatch):
        """
        Test that CLI displays helping character suggestions correctly.

        Verifies:
        - Helping flag displayed
        - Target character name resolved and shown
        - Help justification displayed
        """
        monkeypatch.chdir(tmp_path)

        cli = DMCommandLineInterface()

        # Create action dict with helping flag
        action_dict = {
            "character_id": "char_002_001",
            "narrative_text": "I join Zara-7 in the repair effort.",
            "task_type": "lasers",
            "is_prepared": False,
            "is_expert": False,
            "is_helping": True,
            "helping_character_id": "char_001_001",
            "help_justification": "Two pairs of hands are better than one for this complex repair"
        }

        # Character name resolver
        def resolver(char_id):
            if char_id == "char_001_001":
                return "Zara-7"
            elif char_id == "char_002_001":
                return "Kai Nova"
            return char_id

        # Format dice suggestion with resolver
        suggestion = cli.formatter.format_dice_suggestion(action_dict, resolver)

        assert suggestion is not None
        assert "Helping Zara-7:" in suggestion
        assert "Two pairs of hands" in suggestion
